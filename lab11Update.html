<html lang="ru">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<body>

<canvas width="500" height="500" style="border:1px;"></canvas>

<br>
Поворот X:
<input id="rotateX" type="range" min="-3.1415" max="3.1415" value="0" step="0.0001" oninput="update()">
<b id="infoRotateX"></b><br>
Поворот Y:
<input id="rotateY" type="range" min="-3.1415" max="3.1415" value="0" step="0.0001" oninput="update()">
<b id="infoRotateY"></b><br>
Поворот Z:
<input id="rotateZ" type="range" min="-3.1415" max="3.1415" value="0" step="0.0001" oninput="update()">
<b id="infoRotateZ"></b>
<br>

<script>
    var canvas = document.querySelector("canvas");
    var ctx = canvas.getContext("2d");

    class Vector2d {
        constructor(x, y) {
            this.x = x;
            this.y = y;
        }

        move(mx, my) {
            let x = this.x + mx;
            let y = this.y + my;
            return new Vector2d(x, y);
        }

        scale(w) {
            let x = this.x * w;
            let y = this.y * w;
            return new Vector2d(x, y);
        }

        rotate(angle) {
            let x = this.x * Math.cos(angle) - this.y * Math.sin(angle);
            let y = this.x * Math.sin(angle) + this.y * Math.cos(angle);
            return new Vector2d(x, y);
        }
    }

    class Vector3d {
        constructor(x, y, z) {
            this.x = x;
            this.y = y;
            this.z = z;
        }

        getProjection(dist) { //Получение проекции точек на плоскость
            let x = this.x * dist / this.z;
            let y = this.y * dist / this.z;
            return new Vector2d(x, y);
        }

        move(mx, my, mz) {
            let x = this.x + mx;
            let y = this.y + my;
            let z = this.z + mz;
            return new Vector3d(x, y, z);
        }

        scale(w) {
            let x = this.x * w;
            let y = this.y * w;
            let z = this.z * w;
            return new Vector3d(x, y, z);
        }

        rotate(angleX, angleY, angleZ) {
            let x, y, z;
            let temp = new Vector3d(this.x, this.y, this.z);
            //Вращение вокруг оси 0Y
            x = temp.x * Math.cos(angleY) + (temp.z) * Math.sin(angleY);
            y = temp.y;
            z = -temp.x * Math.sin(angleY) + (temp.z) * Math.cos(angleY);
            temp.x = x;
            temp.y = y;
            temp.z = z;
            //Вращение вокруг оси 0X
            x = temp.x;
            y = temp.y * Math.cos(angleX) + temp.z * Math.sin(angleX);
            z = -temp.y * Math.sin(angleX) + temp.z * Math.cos(angleX);
            temp.x = x;
            temp.y = y;
            temp.z = z;
            //Вращение вокруг оси 0Z
            x = temp.x * Math.cos(angleZ) + temp.y * Math.sin(angleZ);
            y = -temp.x * Math.sin(angleZ) + temp.y * Math.cos(angleZ);
            z = temp.z;
            temp.x = x;
            temp.y = y;
            temp.z = z;
            return temp;
        }

        static copy(vector) {
            return new Vector3d(vector.x, vector.y, vector.z);
        }
    }

    class Pyramid {
        constructor(w, h, l, x, y, z,) {
            this.world = [ //Мировые координаты точек
                new Vector3d(-w, -h, -l),
                new Vector3d(w, -h, -l),
                new Vector3d(-w, -h, l),
                new Vector3d(w, -h, l),
                new Vector3d(w / 2, h / 2, l / 2),
            ];
            this.edges = [ //Связи точек для отрисовки ребер
                [0, 1],
                [0, 2],
                [3, 1],
                [3, 2],

                [0, 4],
                [1, 4],
                [2, 4],
                [3, 4],
            ];
            this.display = [];	//Массив для экранных координат проекций точек.
            this.projection = []; //Массив для координат проекций точек.
            this.scale = 1;
            //Углы поворота куба
            this.angleX = 0;
            this.angleY = 0;
            this.angleZ = 0;
            //Координаты куба
            this.x = x || 0;
            this.y = y || 0;
            this.z = z || 0;
            this.dist = 500;
            //Координаты проекции куба
            this.projX = 0;
            this.projY = 0;
            this.update();
        }

        update() { //Просчет новой проекции исходя из данных координат и углов поворота
            for (let i in this.world) {
                this.display[i] = this.world[i];
                this.display[i] = this.display[i].rotate(this.angleX, this.angleY, this.angleZ);
                this.display[i] = this.display[i].scale(this.scale);
                this.display[i] = this.display[i].move(this.x, this.y, this.z);
                this.projection[i] = this.display[i].getProjection(this.dist); //Получаем проекцию
                this.projection[i] = this.projection[i].move(canvas.width / 2, canvas.height / 2);
            }

        }

        render() {
            for (let it of this.edges) {
                if (!(this.display[it[0]].z >= 0 && this.display[it[1]].z >= 0)) {
                    continue;
                }

                ctx.fillStyle = "#FFF";
                ctx.strokeStyle = "blue";
                ctx.beginPath();
                ctx.moveTo(this.projection[it[0]].x, this.projection[it[0]].y);
                ctx.lineTo(this.projection[it[1]].x, this.projection[it[1]].y);
                ctx.closePath();
                ctx.stroke();
            }

            ctx.fillStyle = "#F00";

            const faces = [
                [
                    this.projection[0],
                    this.projection[1],
                    this.projection[4],
                ],
                [
                    this.projection[0],
                    this.projection[2],
                    this.projection[4],
                ],
                [
                    this.projection[1],
                    this.projection[3],
                    this.projection[4],
                ],
                [
                    this.projection[2],
                    this.projection[3],
                    this.projection[4],
                ],
            ]

            const colors = [
                "#FF595E", "#FFCA3A", "#8AC926", "#1982C4"
            ]

            for (const i in faces) {
                ctx.fillStyle = colors[i]
                const path = new Path2D();
                path.moveTo(faces[i][0].x, faces[i][0].y);
                path.lineTo(faces[i][1].x, faces[i][1].y);
                path.lineTo(faces[i][2].x, faces[i][2].y);
                ctx.fill(path);
            }
        }
    }

    let pypamida = new Pyramid(1, 1, 1, 0, 0, 10);

    function update() {
        ctx.fillStyle = "#FFF";
        let angleX = parseFloat(document.querySelector("#rotateX").value)
        let angleY = parseFloat(document.querySelector("#rotateY").value)
        let angleZ = parseFloat(document.querySelector("#rotateZ").value)
        document.querySelector("#infoRotateX").innerHTML = angleX;
        document.querySelector("#infoRotateY").innerHTML = angleY;
        document.querySelector("#infoRotateZ").innerHTML = angleZ;
        pypamida.angleX = angleX;
        pypamida.angleY = angleY;
        pypamida.angleZ = angleZ;
        pypamida.update() //Просчитываем и применяем новую проекцию исходя из новых координат и углов
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        pypamida.render(); //Отрисовываем пирамиду
    }

    update();
</script>
</body>
</html>